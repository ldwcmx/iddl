/**
 * iddl
 * 
 * Intelligent Distributed Data Layer
 * 
 * iddl-group-datasource
 */
package com.it.iddl.group.jdbc;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.it.iddl.group.AbstractGroupDataSource;
import com.it.iddl.group.dbselector.DBSelector.AbstractDataSourceTryer;
import com.it.iddl.group.dbselector.DBSelector.DataSourceTryer;

/**
 * 
 * @author sihai
 *
 */
public class GroupStatement implements Statement {

	private static final Log logger = LogFactory.getLog(GroupStatement.class);

	protected GroupConnection groupConnection;
	protected AbstractGroupDataSource groupDataSource;
	protected int retryTimes;
	
	protected boolean closed; //当前statment 是否是关闭的
	
	/**
	 * 经过计算后的结果集，允许使用 getResult函数调用.
	 *
	 * 一个statement只允许有一个结果集
	 */
	protected ResultSet currentResultSet;
	
	/**
	 * query time out . 超时时间，如果超时时间不为0。那么超时应该被set到真正的query中。
	 */
	protected int queryTimeout = 0;

	protected int fetchSize;

	protected int maxRows;
	
	/**
	 * 更新计数，如果执行了多次，那么这个值只会返回最后一次执行的结果。 如果是一个query，那么返回的数据应该是-1
	 */
	protected int updateCount;

	protected int resultSetType = ResultSet.TYPE_FORWARD_ONLY;;
	protected int resultSetConcurrency = ResultSet.CONCUR_READ_ONLY;

	//jdbc规范中未指明resultSetHoldability的默认值，要设成ResultSet.CLOSE_CURSORS_AT_COMMIT吗?
	//TODO 统一设成-1吗?
	protected int resultSetHoldability = -1;
	
	/* ========================================================================
	 * 下层(有可能不是真正的)Statement的持有，getter/setter包权限
	 * ======================================================================*/
	private Statement baseStatement;
	
	/**
	 * 
	 */
	protected DataSourceTryer<ResultSet> executeQueryTryer = new AbstractDataSourceTryer<ResultSet>() {
		public ResultSet tryOnDataSource(GroupDataSourceWrapper gdsw, Object... args) throws SQLException {
			String sql = (String) args[0];
			Connection conn = GroupStatement.this.groupConnection.createNewConnection(gdsw, true);
			return executeQueryOnConnection(conn, sql);
		}
	};
	
	/**
	 * 
	 */
	private DataSourceTryer<Integer> executeUpdateTryer = new AbstractDataSourceTryer<Integer>() {
		public Integer tryOnDataSource(GroupDataSourceWrapper gdsw, Object... args) throws SQLException {
			Connection connection = GroupStatement.this.groupConnection.createNewConnection(gdsw, false);
			return executeUpdateOnConnection(connection, (String) args[0], (Integer) args[1], (int[]) args[2],
					(String[]) args[3]);
		}
	};

	public GroupStatement(AbstractGroupDataSource groupDataSource, GroupConnection groupConnection) {
		this.groupDataSource = groupDataSource;
		this.groupConnection = groupConnection;

		this.retryTimes = groupDataSource.getRetryTimes();
	}
	
	private int executeUpdateOnConnection(Connection connection, String sql, int autoGeneratedKeys, int[] columnIndexes,
			String[] columnNames) throws SQLException {
		
		Statement stmt = createStatementInternal(connection, false);

		if (autoGeneratedKeys == -1 && columnIndexes == null && columnNames == null) {
			return stmt.executeUpdate(sql);
		} else if (autoGeneratedKeys != -1) {
			return stmt.executeUpdate(sql, autoGeneratedKeys);
		} else if (columnIndexes != null) {
			return stmt.executeUpdate(sql, columnIndexes);
		} else if (columnNames != null) {
			return stmt.executeUpdate(sql, columnNames);
		} else {
			return stmt.executeUpdate(sql);
		}
	}
	
	/**
	 * 会调用setBaseStatement以关闭已有的Statement
	 */
	private Statement createStatementInternal(Connection connection, boolean isBatch) throws SQLException {
		Statement stmt;
		if (isBatch)
			stmt = connection.createStatement();
		else {
			int resultSetHoldability = this.resultSetHoldability;
			if (resultSetHoldability == -1) //未调用过setResultSetHoldability
				resultSetHoldability = connection.getHoldability();

			stmt = connection.createStatement(this.resultSetType, this.resultSetConcurrency, resultSetHoldability);
		}

		setBaseStatement(stmt); //会关闭已有的Statement
		stmt.setQueryTimeout(queryTimeout); //这句也有可能抛出异常，放在最后
		stmt.setFetchSize(fetchSize);
		stmt.setMaxRows(maxRows);

		return stmt;
	}

	/**
	 * 设置在底层执行的具体的Statement
	 * 如果前面的baseStatement未关，则先关闭
	 * @param baseStatement
	 */
	void setBaseStatement(Statement baseStatement) {
		if (this.baseStatement != null) {
			try {
				this.baseStatement.close();
			} catch (SQLException e) {
				logger.error("close baseStatement failed.", e);
			}
		}
		this.baseStatement = baseStatement;
	}
	
	/* ========================================================================
	 * executeQuery 查询逻辑
	 * ======================================================================*/
	
	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public int executeUpdate(String sql) throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}
	
	/**
	 * 
	 * @param connection
	 * @param sql
	 * @return
	 * @throws SQLException
	 */
	protected ResultSet executeQueryOnConnection(Connection connection, String sql) throws SQLException {
		Statement stmt = createStatementInternal(connection, false);
		this.currentResultSet = stmt.executeQuery(sql);
		return this.currentResultSet;
	}
	

	/* ========================================================================
	 * 关闭逻辑
	 * ======================================================================*/
	/**
	 * 如果新建了查询，那么上一次查询的结果集应该被显示的关闭掉。这才是符合jdbc规范的
	 *
	 * @throws SQLException
	 */
	protected void ensureResultSetIsClosed() throws SQLException {

		if (currentResultSet != null) {
			//log.debug("result set is not null,close current result set");
			try {
				currentResultSet.close();
			} catch (SQLException e) {
				logger.error("exception on close last result set . can do nothing..", e);
			} finally {
				// 最终要显示的关闭它
				currentResultSet = null;
			}
		}

	}
	
	protected void checkClosed() throws SQLException {
		if (closed) {
			throw new SQLException("No operations allowed after statement closed.");
		}
	}
	
	@Override
	public void close() throws SQLException {
		// TODO Auto-generated method stub

	}
	
	public void close(boolean removeThis) throws SQLException {
		if (closed) {
			return;
		}
		closed = true;

		try {
			if (currentResultSet != null)
				currentResultSet.close();
		} catch (SQLException e) {
			logger.warn("Close currentResultSet failed.", e);
		} finally {
			currentResultSet = null;
		}

		try {
			if (this.baseStatement != null)
				this.baseStatement.close();
		} finally {
			this.baseStatement = null;
			if (removeThis)
				groupConnection.removeOpenedStatements(this);
		}
	}
	
	public int getResultSetType() throws SQLException {
		return resultSetType;
	}

	public void setResultSetType(int resultSetType) {
		this.resultSetType = resultSetType;
	}
	
	public void setResultSetConcurrency(int resultSetConcurrency) {
		this.resultSetConcurrency = resultSetConcurrency;
	}

	public void setResultSetHoldability(int resultSetHoldability) {
		this.resultSetHoldability = resultSetHoldability;
	}
	
	@Override
	public int getMaxFieldSize() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public int getMaxRows() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void setMaxRows(int max) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public int getQueryTimeout() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void setQueryTimeout(int seconds) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void cancel() throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void clearWarnings() throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void setCursorName(String name) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public boolean execute(String sql) throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public ResultSet getResultSet() throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public int getUpdateCount() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public int getFetchDirection() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public int getFetchSize() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void addBatch(String sql) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public void clearBatch() throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public int[] executeBatch() throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public Connection getConnection() throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys)
			throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes)
			throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames)
			throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys)
			throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public boolean execute(String sql, String[] columnNames)
			throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public boolean isClosed() throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
		// TODO Auto-generated method stub

	}

	@Override
	public boolean isPoolable() throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}

	///////////////////////////////////////////////////////////////////
	//		For jdk1.6
	///////////////////////////////////////////////////////////////////
	public <T> T unwrap(Class<T> iface) throws SQLException {
		if(isWrapperFor(iface)){
			return (T) this;
		}else{
			throw new SQLException("not a wrapper for "+ iface);
		}
	}
	
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return this.getClass().isAssignableFrom(iface);
	}
	
	///////////////////////////////////////////////////////////////////
	//		For jdk1.7
	///////////////////////////////////////////////////////////////////
	public void closeOnCompletion() throws SQLException {
		// TODO Auto-generated method stub

	}

	public boolean isCloseOnCompletion() throws SQLException {
		// TODO Auto-generated method stub
		return false;
	}
}
